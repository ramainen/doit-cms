О системе DoIt CMS
==================
Общие принципы
--------------
### Принцип упрощения работы приложения
Похожие сущности, малое количество IF, разные формы одно и тоже, малое количество тегов и
правил

### MVC
Используются основные принципы MVC (разделение логики, данных, и функций, их
соединяющих). Реализация отличается от классического подхода.

**Модель** – это класс, который необязательно объявлять, но его экземпляры можно
использовать. Он позволяет обращаться к базе данных как к объектам.

**Контроллер** – это множество функций, переопределяемых при помощи правил роутера. Также
это помощники (helpers , фрагменты разметки, содержащих код), обработчики для форм
(`action('client#update')`), альтернативные валидаторы, функции для отправки электронной
почты и т.д.

**Вид** – это множество функций, объявляемых автоматически на основе файлов с разметкой,
переопределяемых при помощи правил роутера. Может содержать PHP-код, например, для
сложных проверок. Каждая такая функция возвращает готовый HTML-код. Например `print d()->about();`
выведет шаблон about.html.

Также есть несколько дополнительных сущностей:

**Опции** – .ini файлы, которые инициализируют переменные (свойства) основного объекта.
Они же определяют правила роутера, списки полей для системы администрирования, опции
сайта в целом, логин и пароль администратора, правила для валидации форм. При помощи
опций можно переопределить любую функцию или шаблон, или заставить выполниться
дополнительную функцию или дополнительный шаблон, объявить переменную или массив.

**Обработчики форм** – часть контроллера, принимают, проверяют и обрабатывают POST
запросы.

**Помощники (Helpers)** – функции, результат работы которых используется для генерации HTML
кода (формы, поля редактирования, ссылки, метатеги и так далее). Часть контроллера, в
большинстве своём независимые и не привязаны к какому-то определённому контроллеру.

### Отличия от большинства MVC фреймворков
В отличие от большинства MVC фреймворков, данный фреймворк не следует принципу «ООП
ради ООП», не является строго ООП-фреймворком, старается не плодить различные сущности,
а объединять похожие сущности едиными правилами для упрощения схемы работы и
понимания, ставит скорость разработки, поддержки, лаконичность кода, единые принципы и
гибкость выше, чем соблюдение общепринятых принципов MVC .

В отличие от большинства MVC фреймворков, модель не содержит общего кода (например,
отправка электронной почты), и вся логика содержится в контроллере (антипаттерн Fat
Controller или FSUC). Более того, во многих проектах объявление модели может вовсе
отсутствовать.

В отличие от большинства MVC фреймворков, в некоторых случаях допустимо обращаться к
Модели из Вида, минуя контроллер, если это упростит код, его написание или поддержку.
Например:

	<ul>
		<foreach User->all as user>
			<li>{user.login}</li>
		</foreach>
	</ul>
	

Здесь выводятся все записи из таблицы users. Примечание: данный пример усложняет в
дальнейшем работу с кодом (например, добавление фильтраций или сортировки,
переопределение и т.д.). Поэтому всё-таки лучше выводить подобный код в контроллер.

В отличие от большинства MVC фреймворков, контроллер отдельной сущности может быть как
функцией, так и классом с набором методов, так и смесью двух подходов. Более того,
возможна разработка приложения без единого дополнительного класса (как контроллера, так
и модели или иных сущностей) без потери каких-либо возможностей.

В отличие от большинства MVC фреймворков, допустимо использование методов контроллера
напрямую в Виде (при помощи спец. тега), и вызов шаблонов Вида из Контроллера для
дальнейшей обработки (например, замене спец. символов).

В отличие от большинства MVC фреймворков, валидацию проводит не модель, а контроллер. 
Так как модель в контексте данной системы это прослойка для работы с базой данных, то она
не может взять на себя валидацию таких сущностей, как формы обратной связи, формы
фильтрации вывода или формы поиска данных, формы авторизации и выхода из системы,
формы калькуляторов и формы смены опций, т.к. все эти примеры не воздействуют на базу
данных, однако необходимы в реальных приложениях. Если бы валидацию проводила модель
при попытке сохранить данные (например, при редактировании статьи), а валидацию
правильной сортировки и формы отправки сообщения —контроллер, то существовали бы две
различные реализации валидатора, что противоречит принципу упрощения схемы работы
приложения.

В отличие от большинства MVC фреймворков, модель не хранит состояние приложения между
запросами в классическом понимании — модель не отвечает за хранение сессий и cookies.
Однако модель хранит состояние приложения в базе данных.

В отличие от большинства MVC фреймворков, реализация модели близка к классическим CMS,
и использует только MySQL базу данных и не имеет абстракций для работы с другими СУБД
или иными источниками данных.

В отличие от большинства MVC фреймворков, роутер способен влиять на Вид, а также
переопределять дополнительные функции-помощники (например, {{form}} или {{input}})

В отличие от большинства MVC фреймворков, каждый URL не имеет привязанного роутером
контроллера. На одной странице может существовать несколько сущностей, гибко
контролируемым независимо по правилам URL и разными контроллерами. Т.н. классические
«виджеты» (например, форма отправки почтового сообщения или форма авторизации)
работают по тем же принципам, что и основной контент, вызываются одинаково, также могут
быть переопределены по правилам роутера и представляют собой одно и то же, в
соответствии с принципом упрощения схемы работы приложения. Тоже самое касается
фрагментов HTML-вёрстки (например, {{footer}}).

В отличие от большинства MVC фреймворков, layout (разметка всей страницы) и view
(разметка контента страницы) — одна и та же сущность, в соответствии с принципом
упрощения схемы работы приложения. Более того, даже обычные функции — это та же самая
сущность, что и вышеуказанные, и могут вызываться напрямую из вида либо вообще отвечать
за общий layout. Например, если существует функция summa() { return 2+2; }, то следующее
правило в роутере: `/mypage main summa` заставит по адресу http://сайт/mypage вывести число 4 вместо HTML кода разметки.

Переменные и функции
--------------------

TODO: описать следующее


*   d()->var
*   d()->user_controller->func()
*   d('var')
*   {var}
*   {var.title}
*   {var.title|h}
*   {{func}}
*   {{admin#script}}
*   {{helper "mail"}}
*   {{helper "style"=>"color:red;"}}
*   main, content
*   Принцип переопределения
*   Схема работы приложения

Фрагменты
---------

### Объявление фрагмента
Для объявления фрагмента с именем fragmentname необходимо создать файл
fragmentname.html в директории app.

Также можно объявить функцию (например, в файле filename.func.php в директории app),
которая будет возвращать вывод фрагмента.
### Поиск фрагмента
Механизм поиска нужного фрагмента для запуска довольно нетривиален.

1. При попытке запуска функции ищется сама функция с этим именем.
2. Если такая функция отсутствует, то выполняется функция, оканчивающая на _tpl.
3. Если существует файл main.html, то объявится функция main_tpl().

Таким образом, для вставки фрагмента шаблона с именем footer, необходимо создать файл
footer.html и вызвать `{{footer}}` там, где надо. Это сработает только в том случае, если функция
footer() отсутствует (правило 2). Также можно использовать `{{footer_tpl}}`. Также можно создать
файл footer.tpl.html, результат будет абсолютно тем же. Префикс .tpl всегда можно опускать.

Если необходимо использовать обычную функцию, просто объявляется функция.

Если необходимо использовать пару функция/функция-шаблон, то объявляется функция
`clients_show()`, и шаблон clients_show.html
Для вызова первой используется `clients_show()`, для второй `clients_show_tpl()`.

(не реализовано) При вызове обычной функции, если шаблон существует, то он будет
присоединён в цепочке к существующей по умолчанию.

Например, `d()->main()` при отсутствии функции `main()` выполнит `d()->main_tpl();`

Однако, если существует файл main.tpl.html, то объявится функция `main_tpl()`.

Фрагмент по сути есть метод основного объекта системы, который возвращает HTML код либо
промежуточные данные. При наличии файла fragmentname.html такая функция объявится
автоматически.

Имя фрагмента может содержать латинские буквы, цифры и знак подчёркивания (как и
названия функций).

Цепочки вызовов
---------------
Допустим, в роутере указана следующая строка

	/ content default default_tpl
	
Это означает, что на страницах, начинащихся с / (всех) при вызове функции content выполнится
`d()->default()`, а затем `d()->default_tpl()`. В первом файле может проводиться инициализация, а
во втором - вывод.
Можно вызвать безымянную цепочку напрямую: 

	d()->call('default', 'default_tpl');

Каждый
элемент из цепочки не будет переопределён по правилам переопределения.
### set_next_chain

`d()->set_next_chain('название_функции')`
Переопределяет следующий элемент в цепочке
вызовов, определённой в роутере. Она переопределяет следующий элемент в очереди, или
добавляет новый, если такого элемента нет.

например, `d()->set_next_chain('fosv')` вызовет `d()->fosv()` сразу после окончания работы текущей
функции. Её вывод присоединится к выводу текущей функции.

### stop_next_chains
`d()->stop_next_chains()` отменит все следующие функции в цепочке.

Вызов врагментов
----------------
Для вызова фрагмента и получения его вывода необходимо вызвать `doit()->fragmentname();`
Соответственно, для вывода `<?php print doit()->fragmentname(); ?>`

Внутри шаблонов можно использовать `<?php print $this->fragmentname(); ?>`. Все функции
фрагментов не выводят данные, а только возвращают, это означает, что полученные данные
всегда можно дополнительно обработать.

В контексте шаблона можно использовать короткую запись `{{fragmentname}}`.

В процессе работы сайта, как правило, первым вызывается фрагмент `main()`, который вызывает
остальные (например, content для основного содержимого страницы). На комбинации
фрагментов и стоится сайт, с учётом того, что фрагменты могут быть переопределены с учётом
текущего URL (например, переопределён основной макет, середина страницы, заголовок
(header.html), функция получения списка с данными и иные функции по желанию
разработчика).

Если фрагмент или функция вернули `return "текст"`, то вывод переопределится эти текстом.

ini-файлы и их применения
-------------------------
ini - файлы применяются для следующих случаев:


*   роутеры адресов
*   предварительные и последующие вызовы функций
*   поля и их типы для редактирования
*   опции сайта в целом (адреса электронной почты)
*   логины и пароли администраторов
*   такие вещи, как текущий город или страна (для мультирегиональных сайтов)
*   названия и типы полей для редактирования в системе администрирования
*   пути к различным файлам, опции для подключения к базам данных


Стандартные функции
-------------------

### url
Функция url позволяет узнать, какие параметры есть в адресе текущей страницы

Пример использования:

Допустим, URL страницы /users/ainu/comments/13/14/52/page/4/edit?yes=no


	print url() // users/ainu/comments/13/14/52/page/4/edit
	print url(1) // users
	print url(2) // ainu
	print url('users') // ainu
	print url('page') // 4
	print url('comments',3) // 13/14/52
	print url('comments',-2) // 13/14/52/page

Формы, валидаторы и действия (action)
-------------------------------------
TODO:

	{{form}}
	[validator.mail.title]
	d()->action('form#send');

Два типа действий - с перезагрузкой и действием

Модуль Active Record (mod_orm)
------------------------------
mod_orm добавляет поддержку объекта Active Record для упрощения SQL-запросов.

Если функция не имеет параметров, то её можно вызывать в качестве переменной, просто
опустив скобки (в большинстве случаев также доступен классический подход), например

	d()->User->all
	d()->User->one
	d()->User->expand_to_client

### Объявление
Для указания того, какой таблице соответствует объект, ничего не нужно. Объявлять класс для
каждого отдельного типа объекта тоже не обязательно.

Для поиска по таблице users используется запись `d()->Users;`

Например:

	d()->User->find(2)->title;

Для поиска по любой другой таблице используется имя объекта, начинаемое с заглавной
буквы, и представляющее собой название таблицы в единственном числе по правилам
английской грамматики.

Например, `d()->Category` ищет по таблице categories, а `d()->News` ищет по таблице news

Альтернативная запись `d('User')` (Примечание: такая запись подходит для запроса любого
свойства основного объекта, например, `d('title')`).

Для дальнейшего использования можно передавать вызовы по цепочке или используя
промежуточный объект:

	print d()->User->find(2)->title;

равнозначно

	$user= d()->User;
	$user=$user->find(2);
	print $user->title;

либо равнозначно

	$user2= d()->User;
	$user2->find(2);
	print $user2->login;
	
Также разрешён альтернативный подход

	$user2= new User();
	$user2->find(2);
	print $user2->login;

Также разрешается объявлять класс самому, наследуя его от класса ar

В этом случае имеется возможность использовать свои методы класса и переопределять
существующие.

### find()

Осуществляет поиск по id

	d()->User->find(34);
	
Непосредственно запрос выполнится перед получением данных (ленивый запрос).

Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### find_by_<field>

Ищет по определённому полю и автоматически экранирует запрос для предотвращения SQL-
инъекций. Например:

	d()->User->find_by_login('ainu') 	// ищет по полю login
	d()->User->find_by_username('ainu') // ищет по полю username
	
Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### where()

where задаёт условия для будущего запроса и автоматически экранирует запрос для
предотвращения SQL-инъекций. Отменяет действие выполненных ранее функций `find()`,
`find_by_*()`, `where()`

Например:

	d('User')->where('login = ? and password=?', $username, md5($password));
	d('User')->where('login LIKE ?', '%строка%');
	
###all
Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов ActiveRecord).

	$goods = d()->Good->find_by_color('red')->all;
	print $goods[0]->title;
	
### one
Выполняет SQL-запрос (если не выполнен) и возвращает один объект (первый) в виде
ассоциативного массива поле=>значение.

	$maika = d()->Good->find(12)->one;
	
### is_empty
Немедленно выполняет SQL - запрос (до попытки получения первого свойства), и возвращает
true, если получено 0 элементов.
### expand и expand_to
Функции копируют данные из ActiveRecord объекта в глобальную область объектов для
использования в шаблонах

	d('Text')->find_by_url(url(1))->expand_to_page;
	
После этого в шаблоне можно указывать `{page.title}`

	d()->Client->find_by_name('Керхер')->expand_to_client;
	
После этого в шаблоне можно указывать `{client.title}`

	d()->Client->find(374)->expand;
	
После этого в шаблоне можно указывать `{title}`

Примечание: от функции expand можно отказаться классическим методом:

	d()->page = d('Text')->find_by_url(url(1));
	
После этого в шаблоне можно указывать `{page.title}`

Возвращает `false`, если подходящих строк не было найдено.

### new, save и delete
`save` и `delete` завершают предыдущие операции, используются для установки флага
дальнейшего создания строки в базе данных, сохранения данных и удаления строки.

`delete` - удаляет последний найденный через find элемент, если элементы искались через
where, то удаляется первый. Фактически, при `$var->delete;` удаляется элемент с id, равным `$var->id`.

Если такой строки нет, ничего не произойдёт.

`save` - сохраняет изменения. Функция new не совершает никаких действий с базой данных,
только указывает на необходимость создания новой строки в базе данных. Если до save было
сделано $var->new, то при сохранении создастся новая строка, иначе изменится последняя
найденная через find или where строка. Если при попытке сохранения для изменений после
поиска строк было несколько, то изменится первая. Фактически, при $var->save; меняется
элемент с `id` = $var->id. Если такой строки нет, ничего не произойдёт.

Для задания поля необходимо присвоить значение соответствующей переменной. Например,

	$var->title='Заголовок';
	
Внимание: регистр букв важен.
Итак, основные действия:

**Создание:**

	d()->client = d()->Client->new;
	d()->client->title='ainu';
	d()->client->text='Суперклиент';
	d()->client->save();
	
**Редактирование:**

	d()->client = d()->Client->find(12);
	d()->client->title = "Новый заголовок";
	d()->client->save();
	
**Удаление:**

	d()->client = d()->Client->find(12);
	d()->client->delete();
	
Если (например, при редактировании или создании) не было присвоено значение полю, то в
самом запросе с этим полем действий не произойдёт. На данном этапе абстракций нет,
поэтому для указания, например, автора статьи, необходимо указывать id:

	$article = d()->Article->new;
	$article->author_id = 21;
	$article->save;
	
При указании `->new` можно действовать так:

	d()->client = d()->Client;
	d()->client->new;
	d()->client->title='Имя';
	d()->client->save;
	
или так:

	d()->client = d()->Client;
	d()->client->new->title='Имя';
	d()->client->save;
	
или вообще без промежуточного объекта:

	d()->Client->find(7)->delete();
	
### Связи

Все три вида связей (one-to-many, many-to-one, many-to-many) объявляются автоматически.

TODO:

	$user->posts
	$post->user

