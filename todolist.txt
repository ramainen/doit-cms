+Перевести систему на UTF-8
+Система хранения полей в .ini файлах. Загрузка fileds/catalog.ini.
+Кавычки в ini-перечислениях
+Хранение левого меню в отдельном init-файле.
Трёхуровневая система пользоваетелей (направление, группа, пользователь)
+Роутеры в ini-файле
+foreach и функции
+Авторизация разработчика/администратора
ini-файлы, редактируемые администратором.
Псевдосвойства, начиная от приписанных и заканчивая префиксами свойств, например magic_title
Псевдосвойства: проверка на случай, если и переменная, и фрагмент отсуствуют
Кеширование в getFunctionAlias
shablonize: сделать массив str_replace-ов для скорости и поддержки плагинов
<function fields>	</function> Не срабатывает. Игнорится. Создаёт функцию-фрагмент 
Приписывание необязательного параметра namespace для loadandparseini
Функция (команда) специального подавления последнего вывода.
Свойство Parent, связанные списки, подменю
Редактирование верхнего меню админки
Предусмотреть папки в tpl (для админки, для того, чтобы не коммитить вёрстку конкретного проекта (например, вывод логики проекта в отдельную папку, вывод макета/вёрстки проекта - во вторую, админку - в третью, общие классы - в четвёртую)
Почистить вёрстку admin.html
Логика на основе переменных и массивов. Переменные редактируются администратором, факт их инициализации происходит при совпадении URL. Таким образом, администратоор может создать исключение для правила URL и задать исключению текстовую информацию.\
Отказ от eval при вызове, использование прекомпиляции либо eval('function name (){} ');
Предусмотреть откат и нахождение изначальных значений при переопределении тегом fragment одноимённого файла
fragment-локальный
тоесть внутри функции admin либо становятся доступны фрагменты, объявленные внутри этой функции, либо допускается запрос admin_row, admin_list, admin_formtable
+фрагменты объявляются автоматически при заходе в родительскую функцию.
before_, after_, around_, replace_, action_, (обрабатывает POST, делает перенаправления, если вернул false, то не продолжать дальнейший вывод)
override перед вызовом функции как таковой(?). Например, для хранения переопределений в самой базе данных.
Правила в override (какой шаблон на что меняем)
Ruby-style именования. Например, если мы запрашиваем "user" при наличии "users", то система должна понять, что от неё хочет получить человек.
override в четвёртом столбце полей редактирования (добавление разного рода кнопок, переключателей и т.д.).
override в списках редактирования должен поступать умно.
Параметры в foreach
Свои списки в админке
admin/приемник (add[], edit[]), обработчик + обычные формы в админке
<if array> (exists)
<namespace user>
function property_()
namespace_user() получение данных для namespace-а
url()
{user.list}


admin/list/text/123  -- список объектов дочерних к 123, дочерних по свйоству parent
admin/te

магические свойства (при редактировании объекта)
url - адрес
parent - родительская страница (объект)
foreach для
<fragment options.url>
а также
{options.url}
{user.adress}
{{user.add}}
{{database.write}}

{{getdata}} - попытка получить данные автоматически.


Авторизация пользователя
1. я залогинен или нет? if(iam('admin'))  или isset  session admin/developer/user
2. вывод формы авторизации (сообщения: нотис)
3. авторизация (обработка POST), проверка на правильность, указывание переменной $_SESSION['login']

Роутер, обрабатывающий действия, пришедшие из POST, и направляющий их далее.
Всегда делает header(location)

модель содержит функции вычисления массивов (например, меню)


Модель загружается вся.
Необходимо загружать модели только для необходимых модулей (администратор, импорт и так далее)
С другой стороны, functions тоже загружалась вся.
Модель - объявления функций для работы с данными и активными действиями (послать письмо, зарегистрировать пользователя)
Контроллер - код, вызывающий эти функции и передающий дальше в вид

Применения ini-файлов:
роутеры адресов, предварительные и последующие вызовы функций
поля и их типы для редактирования
опции сайта в целом (адреса электронной почты)
логины и пароли администраторов
такие вещи, как текущий город или страна (для мультирегиональных сайтов)



TODO: функция поглотить()
допустим массив array $users:
$users[0].username='ainu';
$users[1].username='anonymous';
$users[1].username='cooler';
	
foreach users as user {
	поглотить (user)
	print $do->username
}
Аналогом функции является одна строка
foreach($user as $subkey=>$subvalue) {
	$this->datapool[$subkey]=$subvalue;
}

Делать прозрачные поиски например
$a=1;
print $this->a; должно выводить 1

TODO:
уровневая система пользователей и групп
1. Направление пользователей (разработчики, администраторы контента сайта, пользователи сайта, продавцы.
или продавцы, покапатели, администраторы)
Каждое направление пользователей имеет свой флаг залогиненности, и разные контроллеры, и разное место хранения списка пользователей
Человек может иметь несколько аккаунтов в разных направлениях (он может быть администратором сайта и покупателем).

2. Группы. Каждая группа имеет свои права
Каждый пользователь может состоять в нескольких группах.

3. Пользователь. Каждый пользователь имеет логин, пароль, группу.

СИстема редактирования инишек администратором
Загрузка всех ini файлов.
!!!!!!!!!!т.е. при загрузке fileds загружаются filelds.*.ini //альтернативно!!!!!

1. иницаизизцаия опций конкертного проекта:
содержит поля:
текстовое описание - тип поля

тип поля выбирается из большо йбазы существующих полей

